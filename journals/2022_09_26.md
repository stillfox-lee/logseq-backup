- 提升 [[k8s operator]]的可用性 #Reading
  id:: 63307b26-0658-4681-939f-56456970074b
	- [ref](https://itnext.io/kubernetes-operator-development-guidelines-for-improved-usability-222390b00dc4)
	- TODO 输出一篇[[blog]]
	-
	- https://miro.medium.com/max/1400/1*HhofnJCiAOlma0eeJLCXSw.jpeg
	- 设计准则
		- 使用声明式设计，而不是命令式。
		- 优先使用k8s 自身的机制
			- 使用 CRD、Aggregated API Server、Custom Sub-resource 来构建
		- 确定 CR 的 metrics 策略
			- 制定自定义资源对应的 metrics 指标，可以提高 controller 的可观测性。一个方案是：将 controller 的 metric 暴露给类似于 Prometheus。如果不想在 controller 的代码中处理 metric 的话，也可以通过 k8s 的审计日志来完成。
		- 把 CRD 注册为 [[Helm]] chart 的一部分
			- 有些controller的实现中，是将 CRD 在代码库中有一份，然后 chart 另外维护一份 CRD。可以通过统一使用 chart 管理 CRD。
		- 如果依赖于[[etcd]]
			- 如果 Operator 依赖使用 etcd 作为存储。那么在 [[Helm]]的 chart 中把 etcd 作为可配置项。使用者可以自定义配置如何使用 etcd：使用集群中已有的实例，为Operator独立部署实例。
	- 实现准则
		-
- TODO [[k8s]] 的 Kubernetes Audit Logs工作原理，应用场景。
-
- [[k8s]] API Extensions 的模式 #[[k8s programming]]
	- API extension 通过`CRD`或者`Aggregated API Server`来实现。使用这个机制构建的 API 可以直接通过`kubectl`来访问，不需要另外的 CLI。
	- 几种常见的模式
		- **Custom Kind+Custom Controller**
			- 这是最流行的模式，通过自定义 Kind 声明特定的[[领域模型]]。用自定义 Controller 协调集群状态。可以通过使用`CRD`或者`Aggregated API Server`来实现。
			- 使用`CRD`可以参考[sample-controller](https://github.com/kubernetes/sample-controller)为例。
			- 使用`Aggregated API Server`可以参考[sample-apiserver](https://github.com/kubernetes/sample-apiserver)为例。
		- **Custom Kind+Custom Controller+Custom sub-resource**
		  与上一个模式类似，但是它允许对自定义的 Kind 进行除`CRUD`外的操作。这种模式就需要用`Aggregated API Server`来实现了。
		- **Custom Controller+ Custom sub-resource**
		  这种模式没有定义一个新的 Kind，Controller 对已有的 Kind进行处理。自定义子资源用于 Controller 查询信息。一个例子是：Controller 搜集并维护各种 k8s 的对象的动态组合信息，用自定义子资源获取这些信息。这种模式只能用`Aggregated API Server`来实现。
		- **Custom sub-resource**
		- 这种模式通常用自定义子资源来存储一些 k8s 对象的信息。例如：metrics server。它从 Prometheus 获取信息，通过自定义 sub-resource 来提供。这种模式也只能用`Aggregated API Server`实现。
		- 参考[custom-metrics-apiserver](https://github.com/kubernetes-sigs/custom-metrics-apiserver)实现
		-
		-
	-