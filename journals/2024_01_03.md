- ![Overlay Filesystem.pdf](../assets/Overlay_Filesystem_1704252592610_0.pdf)
	- 文档里面有多个 filesystem，但是他们的含义不一样。
		- 在操作系统层面，filesystem 指的是 NFS、EXTS 等文件系统
		- 在 Overlay 层面，可以指的是 upper、lower
	- 翻译内容
		- ((65950aa8-f173-4864-a841-e29136051699))
			- > Overlay文件系统结合了两个文件系统 - 一个“上层”文件系统和一个“下层”文件系统。当一个名称同时存在于两个文件系统中时，“上层”文件系统中的对象是可见的，而“下层”文件系统中的对象要么被隐藏，要么（对于目录而言）与“上层”对象合并。
			- > 更准确地说，我们应该将其称为上层和下层的“目录树”，而不是“文件系统”，因为两个目录树很可能位于同一个文件系统中，并且没有必要为上层或下层指定文件系统的根目录。
			- > Linux支持的文件系统范围广泛，可以作为下层文件系统，但并非所有可由Linux挂载的文件系统都具有OverlayFS所需的功能。下层文件系统不需要是可写的。下层文件系统甚至可以是另一个overlayfs。上层文件系统通常是可写的，如果是可写的，它必须支持创建`trusted.*``user.*`扩展属性二者，或其中之一。并且必须在`readdir`响应中提供有效的`d_type`，因此NFS不适用。
		- ((65950409-535e-4ded-ad16-a07d2a46d47c))
			- > Overlay主要涉及目录。如果一个给定的名称同时出现在上层和下层文件系统中，并且在上下层文件系统中都指向一个非目录对象，那么下层对象将被隐藏 - 该名称只指向上层对象。
			  当上层和下层对象都是目录时，将形成一个合并的目录。
			- > 在挂载时，作为挂载选项“lowerdir”和“upperdir”给出的两个目录将合并为一个merged目录：`mount -t overlay overlay -olowerdir=/lower,upperdir=/upper,workdir=/work /merged`
			- > “workdir”需要是与upperdir相同文件系统中的空目录。
			- > 然后，每当在这样的merged 目录中执行查找时，将在每个实际目录中执行查找，并将合并结果缓存在属于overlay文件系统的dentry中。如果两个实际查找都找到目录，则两者都将被存储，并创建一个合并的目录；否则只存储一个：如果存在上层目录，则存储上层目录，否则存储下层目录。
			- > 只有目录中的名称列表会被合并。其他内容，如元数据和扩展属性，仅报告给上层目录。下层目录的这些属性将被隐藏。
		- ((659507a6-f8a9-427b-a4d4-4e90218e8060)) **如何实现删除**
			- > 为了支持 rm 和 rmdir 而不改变下层文件系统，Overlay文件系统需要在上层文件系统中记录文件已被删除的信息。这是通过使用whiteouts和opaque directories（非目录始终是opaque）来实现的。
			- > Whiteout是作为设备号为0/0的字符设备创建的。当在合并目录的上层发现whiteout时，会忽略在下层相匹配的名称，并且whiteout本身也会被隐藏。
			- > 通过将xattr "trusted.overlay.opaque"设置为"y"来使目录变为opaque。如果上层文件系统包含一个opaque目录，那么在下层文件系统中具有相同名称的任何目录都将被忽略。
		- ((6595092a-f7ad-4b31-a143-4b2794b7e055)) readdir 系统调用
			- > 当对合并的目录进行`readdir`请求时，会分别读取上层和下层目录，然后将名称列表以明显的方式合并（首先读取上层，然后读取下层 - 已存在的条目不会被重新添加）。这个合并的名称列表被缓存在`struct file`中，因此只要文件保持打开状态，它就会保持不变。如果目录同时被两个进程打开并读取，它们将各自拥有独立的缓存。对目录进行`seekdir`到目录的开头（偏移量为0），然后进行readdir将导致缓存被丢弃并重新构建。
			  这意味着在读取目录时，对合并目录的更改不会立即显示。这对许多程序来说可能不容易被注意到。
			- > 当读取目录时，seek偏移量是按顺序分配的。因此，如果：
			  1. 读取目录的一部分
			  2. 记住一个偏移量，并关闭目录
			  3. 一段时间后重新打开目录
			  4. 寻找到记住的偏移量
			- > 在文件名列表中，旧位置和新位置之间可能几乎没有关联，特别是如果目录中有任何更改。
			- > 对于未合并的目录进行'readdir'操作，只是简单地由底层目录（上层或下层）处理。
		- ((65950fe4-5bdd-4b6e-b0f6-cea9c549b160)) 重命名目录的实现
			- > 当重命名一个位于下层或合并的目录时（即该目录最初不是在上层创建的），overlayfs 可以用两种不同的方式处理它：
			  1. 返回 EXDEV 错误：当尝试在文件系统边界之间移动文件或目录时，rename(2)会返回此错误。因此，应用程序通常会准备处理此错误（例如，mv(1)会递归地复制目录树）。这是默认行为。
			  2. 如果启用了 "redirect_dir" 功能，则目录将被复制上来（但不包括内容）。然后会设置 "trusted.overlay.redirect" 扩展属性为原始位置的路径，从 overlay 的根目录开始。最后，目录将被移动到新位置。
		- ((65951358-f7d0-4349-8153-e510d5739702)) 非目录对象的处理逻辑
			- > Overlay 文件系统会根据需要从上层或下层文件系统中呈现非目录对象（文件、符号链接、设备特殊文件等）。当以需要写访问权限的方式访问下层文件系统中的文件时，比如以写访问方式打开、更改一些元数据等，该文件首先会从下层文件系统复制到上层文件系统（进行 copy_up 操作）。需要注意的是，创建硬链接也需要进行 copy_up 操作，尽管创建符号链接则不需要。
			- > copy_up 操作可能是不必要的，例如，如果以read-write方式打开件但未修改数据。
			- > copy_up 过程首先确保上层文件系统中存在包含目录，必要时会创建它和任何父目录。然后，它使用相同的元数据（所有者、模式、修改时间、符号链接目标等）创建对象，如果对象是文件，则将数据从下层复制到上层文件系统。最后，会将任何扩展属性一并复制上去。
			  完成 copy_up 操作后，Overlay 文件系统简单地提供对上层文件系统中新创建的文件的直接访问 - 对文件的未来操作几乎不会被 Overlay 文件系统注意到（尽管对文件名的操作，如重命名或取消链接，当然会被注意到并处理）。
		- ((6597db3f-d50c-4152-b27d-51ab291d3032))
			- > 将 Lower 在多个 Overlay 中挂载，的确是一个常用的方式。两个 Overlay 的挂载中可能使用同一个 Lower 路径；也可能使用另一 Overlay 中stack Lower 中的上、下层。
			- > 如果尝试挂载已经在其他 Overlay 中的 Upper 或者 Workdir的话，会发生`EBUSY`错误。使用部分重叠的路径也是不允许的，可能会发生`EBUSY`错误。如果两个 Overlay 中，有 Upper 或者 Workdir 是共享的话，访问其中的文件的行为是未知的，尽管它不会引发 crash 或者 deadlock。
			- > 如果一个 Upper 曾经在一个 Overlay 中使用（已经卸载）。现在使用另一个 Lower和这个挂载过的 Upper 一起挂载是允许的。除非你启用了`inodes index`或者`metadata only copy up`特性。
			-
			-
	- 架构
		- lowerdir  —— 不需要是可写的
		- upperdir —— 可写的
		- workdir —— 一些元数据
		- merged —— 这个目录是最终用于 mount 的。merged 只是一个view。
		- copy_up
			- copy_up 是指在 Overlay 文件系统中，当以需要写访问权限的方式访问下层文件系统中的文件时，该文件首先会从下层文件系统复制到上层文件系统的操作。这个过程确保在进行写操作之前，文件会被复制到上层文件系统，以确保对文件的修改不会影响到下层文件系统中的原始文件。
	- 具体工作原理
		- 通过 upper 和 lower 合并，对外呈现“一个”文件树。upper 的overlay object 是可见的，lower 的对象要么被隐藏，要么与 upper 一起被 merge为一个 overlay object。
		- merge 的逻辑：
			- 如果是目录，那么 upper 和 lower 一起 merge 出一个目录
			- 如果不是目录，那么 lower 的隐藏，只显示 upper
			- **在查找的时候才会实际执行 merge**
			-
	- 分几种使用场景来讨论 Overlay fs 如何工作
		- 删除
		- readdir
		- 重命名目录
-